#+title: data steward survey 2021 --- processing & scratchpad
# this sets the properties for all R source code blocks, so they are all related to the session
#+property: header-args:R  :session *R:survey* :exports results :results output :eval no-export

* libraries
#+begin_src R :results none
  # install.packages("tidyverse")
  library(tidyverse)

  #remotes::install_github("davidsjoberg/ggsankey")
  library(ggsankey)
  # install.packages("ggalluvial")
  ## library(ggalluvial)
  # install.packages("tidylog")

  # install.packages("ggwordcloud")
  library(ggwordcloud)
#+end_src

* read in the data                                     :noexport:
** just the ES survey results
#+begin_src R :results none :eval never
  raw <- read_csv(
    ## "dat/2021 Earth Sciences Data Steward Survey_November 29, 2021_03.23.csv",
    "dat/2021 Earth Sciences Data Steward Survey_December 6, 2021_02.20.csv",
    trim_ws = TRUE, col_names = TRUE)

  dat <- raw |>
    tidylog::filter(StartDate != "Start Date") |>
    tidylog::filter(!stringr::str_detect(StartDate, "[{]")) |>
    type_convert(col_types = "TTccidcT?????????????????????????????????????????????????????????????") |>
    tidylog::mutate(Finished = ifelse(Finished == "True", TRUE, FALSE),
                    Consent = ifelse(Consent == "Yes", TRUE, FALSE))

  glimpse(dat)
#+end_src

** read in all the departmental files at once
list the files
#+begin_src R
  dat <- tibble(file = list.files("dat", pattern = "^2021_fall_results_[A-Z]{2,}.csv"))
#+end_src

#+RESULTS:

then read them in
#+begin_src R :results none
  dat <- dat |>
    mutate(department = case_when(str_detect(file, "ES") ~ "Earth Sciences",
                                  str_detect(file, "FG") ~ "Physical Geography",
                                  str_detect(file, "SGPL") ~ "Human Geography\nand Spatial Planning",
                                  str_detect(file, "SD") ~ "Sustainable Development",
                                  TRUE ~ NA_character_)) |>
    mutate(raw = map(paste0("dat/", file), read_csv, na = c("N/A"), trim_ws = TRUE, col_names = TRUE))
#+end_src

fix column names
#+begin_src R
  dat$raw[[1]] <- rename(dat$raw[[1]],
                         `Researcher Level` = Contact,
                         `Researcher Level_7_TEXT` = Contact_7_TEXT,
                         Contact = Q36,
                         Contact_1_TEXT = Q36_1_TEXT)

  dat$raw[[2]] <- rename(dat$raw[[2]],
                         `Researcher Level` = Contact,
                         `Researcher Level_7_TEXT` = Contact_7_TEXT,
                         Contact = Q39,
                         Contact_1_TEXT = Q39_1_TEXT)
#+end_src

#+RESULTS:

unnest them and clean 'em up
#+begin_src R :results none
  dat <- dat |>
    unnest(raw) |>
    tidylog::filter(StartDate != "Start Date") |> # remove first row
    tidylog::filter(!stringr::str_detect(StartDate, "[{]")) |> # remove row with no data
    type_convert() |>
    tidylog::mutate(Finished = ifelse(Finished == "True", TRUE, FALSE), # convert to booleans
                    Consent = ifelse(Consent == "Yes", TRUE, FALSE))
#+end_src

* read in the questions/types
Unfortunately, I had to make this manually. It's necessary for the plot titles and such.
#+begin_src R :results none
  Qs <- read_csv("dat/survey_questions.csv") |>
     mutate(clarification = ifelse(is.na(clarification), "", clarification))
#+end_src

** did we put all the necessary columns in the file?
#+begin_src R :results value
  colnames(dat)[!colnames(dat) %in% Qs$column]
#+end_src

#+RESULTS:
| file                  |
| department            |
| StartDate             |
| EndDate               |
| Status                |
| IPAddress             |
| Progress              |
| Duration (in seconds) |
| Finished              |
| RecordedDate          |
| ResponseId            |
| RecipientLastName     |
| RecipientFirstName    |
| RecipientEmail        |
| ExternalReference     |
| LocationLatitude      |
| LocationLongitude     |
| DistributionChannel   |
| UserLanguage          |

looks like I did, these are only tracking metadata which are mostly empty because we used anonymous urls to get the survey responses.
* tidy the data                                        :noexport:
** tidy up all multiselect answers so they can be split up if desired
inspect all unique values in a variable
#+begin_src R :results none
  dat |> distinct(`Data Types`)
#+end_src

Tidy up the multiselect answers (remove parentheses and commas)
#+begin_src R :results none
  dat <-
    dat |>
    # get rid of examples
    tidylog::mutate(`Data Types` = str_replace_all(`Data Types`, " \\([0-9A-Za-z, ]+\\)", "")) |>
    tidylog::mutate(`Data Collection` = str_replace_all(`Data Collection`, "machine ,", "machine,")) |>
    tidylog::mutate(`Data Collection` = str_replace_all(`Data Collection`, " \\(.*\\)", "")) |>
    # this has Yes, answers everywhere, just replace the , with a :
    tidylog::mutate(`Data Re-use` = str_replace_all(`Data Re-use`, "Yes,", "Yes:")) |>
    # Data Storage is fine!
    tidylog::mutate(`Data Backup` = str_replace_all(`Data Backup`, " \\(.*\\)", "")) |>
    # File Structure = fine
    # FAIR Application is single-select
    tidylog::mutate(`Storage` = str_replace_all(`Storage`, ", namely", "; namely")) |>
    tidylog::mutate(`Open Data Formats` = str_replace_all(`Open Data Formats`, " \\(.*\\)", "")) |>
    tidylog::mutate(`Open Data Formats` = str_replace_all(`Open Data Formats`, ", I use", "; I use")) |>
    # Conversion is good
    # Project Replication is fine
    tidylog::mutate(`Metadata Provided` = str_replace_all(`Metadata Provided`, " \\(.*\\)", "")) |>
    tidylog::mutate(`Skip Code` = str_replace_all(`Skip Code`, " \\([0-9A-Za-z, +]+\\)", "")) |>
    tidylog::mutate(`Skip Code` = str_replace_all(`Skip Code`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Skip Code` = str_replace_all(`Skip Code`, "No,", "No:")) |>
    tidylog::mutate(`Versioning` = str_replace_all(`Versioning`, "\\([0-9A-Za-z, +]+\\)", "")) |>
    tidylog::mutate(`Versioning` = str_replace_all(`Versioning`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Versioning` = str_replace_all(`Versioning`, "No,", "No:")) |>
    # Publication location is good
    tidylog::mutate(`Code License` = str_replace_all(`Code License`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Code License` = str_replace_all(`Code License`, "No,", "No:")) |>
    tidylog::mutate(`Code License` = str_replace_all(`Code License`, " \\(.*\\)", "")) |>
    # Code DOI is good
    # Personal Data Bool is fine
    tidylog::mutate(`Personal Data Bool` = str_replace_all(`Personal Data Bool`, " \\(.*\\)", "")) |>
    # GDPR Work
    # Privacy Review DPIA
    # Sharing Private Data
    # Personal Training
    # Finding Privacy
    # Neg Consequences
    # Ethic Considerations
    tidylog::mutate(`Research Guidelines` = str_replace_all(`Research Guidelines`, " \\(.*\\)", "")) |>
    tidylog::mutate(`Research Guidelines` = str_replace_all(`Research Guidelines`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Research Guidelines` = str_replace_all(`Research Guidelines`, "No,", "No: ")) |>
    tidylog::mutate(`Contact` = str_replace_all(`Contact`, " \\(.*\\)", ""))
#+end_src

Doing the actual split results in way too many rows, messing up the counts.
Thus it needs to be done separately for each plot?
** clean up research guidelines
Turns out we messed this question up a bit
#+begin_src R :results none
  distinct(dat, `Research Guidelines`)
#+end_src

#+begin_src R :results none
  dat <- dat |>
    mutate(`Research Guidelines` = `Research Guidelines` |>
             str_replace_all("^No$", "No: I don't know any guidelines") |>
             str_replace_all("^I don't know any guidelines", "No: I don't know any guidelines") |>
             str_replace_all(",I don't know any guidelines", ",No: I don't know any guidelines"))
  dat |>
    distinct(`Research Guidelines`)
#+end_src
** there are some inconsistent selection options (where individual departments use different capitalization)
#+begin_src R
  dat <- dat |>
    tidylog::mutate(`Storage` = str_replace_all(`Storage`, "Field Specific", "Field-Specific"))
#+end_src

#+RESULTS:
: mutate: changed 36 values (13%) of 'Storage' (0 new NA)

** COMMENT replace NA with hard coded "N/A" for nicer sankey diagrams
I don't like this too much, only do it for the sankey diagrams
#+begin_src R :results none :eval never
   dat <- dat |>
    tidylog::mutate(across(.cols = where(~ is.character(.x)), .fns = ~ replace(.x, is.na(.x), "N/A")))
#+end_src

** NEXT tidy up open text entries for summaries
I've marked all columns that could do with some cleaning up in yellow in the [[file:dat/survey_questions.ods]] file

** filter out people who did not give consent
#+begin_src R
  dat <- dat |>
     tidylog::filter(!Consent | !is.na(Consent)) # no consent or not filled out
#+end_src

#+RESULTS:
: filter: removed 40 rows (14%), 243 rows remaining

** filter out people who did not fill out any of the questions
#+begin_src R
  empty <- dat |>
    mutate(across(.cols = `Data Types`:Contact_1_TEXT, .fns = is.na)) %>%
    mutate(allcols = rowSums(select(., `Data Types`:Contact_1_TEXT)) ==
             colnames(dat |> select(`Data Types`:Contact_1_TEXT)) |> length())

  dat <- dat |>
    tidylog::filter(!ResponseId %in% empty$ResponseId[empty$allcols])
#+end_src

#+RESULTS:
: filter: removed 43 rows (18%), 200 rows remaining

** get rid of the capitalization differences between the different surveys
:PROPERTIES:
:CREATED:  [2022-01-10 Mon 11:49]
:END:
#+begin_src R
  dat <- dat |>
    tidylog::mutate(across(c(`Data Types`, `Data Collection`, `Data Storage`,
                             `Data Backup`, `File Structure`, `Storage`, `Code DOI`),
                           str_to_lower))
#+end_src

#+RESULTS:
: mutate: changed 199 values (>99%) of 'Data Types' (0 new NA)
:         changed 199 values (>99%) of 'Data Collection' (0 new NA)
:         changed 198 values (99%) of 'Data Storage' (0 new NA)
:         changed 199 values (>99%) of 'Data Backup' (0 new NA)
:         changed 199 values (>99%) of 'File Structure' (0 new NA)
:         changed 188 values (94%) of 'Storage' (0 new NA)
:         changed 114 values (57%) of 'Code DOI' (0 new NA)

Data Types has changed capitalization within SD and SGPL

** export cleaned up data
#+begin_src R :results none
  dat |>
    write_rds("out/tidy_survey.rds")
#+end_src

* read in cleaned up data
#+begin_src R :results none
  dat <- read_rds("out/tidy_survey.rds")
#+end_src

* design an approach
** get an overview of survey respondents
Some of these will be used to filter out non-real participants from the survey results.
*** did people complete the survey?
#+begin_src R :results output graphics file :file imgs/responses.png :width 800
  dat |>
    arrange(RecordedDate) |>
    ## tidylog::filter(!is.na(Consent)) |> # 9 people didn't give consent and then didn't fill anything out
    ## tidylog::filter(`Duration (in seconds)` < 60 * 60) |> # 6 more took longer than an hour
    ## tidylog::filter(Progress > 50) |>  # 9 remaining people were less than 50% complete
    ggplot(aes(x = StartDate, xend = EndDate, y = `Duration (in seconds)` / 60, colour = Progress)) +
    geom_segment(aes(yend = `Duration (in seconds)` / 60, group = ResponseId), size = 1.5) +
    geom_point(aes(x = RecordedDate)) +
    scale_colour_viridis_c(direction = -1) +
    labs(y = "Duration (in minutes)") +
    facet_grid(rows = vars(department))
#+end_src

#+RESULTS:
[[file:imgs/responses.png]]
*** how long did people actually take to fill out the survey?
#+begin_src R :results output graphics file :file imgs/duration.png :width 800
  dat |>
    ggplot(aes(x = `Duration (in seconds)`/60, fill = department)) +
    geom_histogram(binwidth = 10) +
    geom_vline(xintercept = median(dat$`Duration (in seconds)`) / 60) +
    labs(x = "Duration (in minutes)") +
    coord_cartesian(xlim = c(-10, 500))
#+end_src

#+RESULTS:
[[file:imgs/duration.png]]

The people who finished filling out the survey took about 10.28 minutes!

#+begin_src R :results none
  median(dat$`Duration (in seconds)`) / 60
#+end_src

#+begin_src R :results none
  getmode <- function(v) {
     uniqv <- unique(v)
     uniqv[which.max(tabulate(match(v, uniqv)))]
  }

  getmode(dat$`Duration (in seconds)`) / 60
#+end_src

with a mode of about 6 minutes.

*** did the partially complete cases give useful input?
#+begin_src R :results none
  dat |>
    tidylog::filter(!Finished) |>
    select(Consent:Q36_1_TEXT) |>
    as.data.frame() |>
    print()
#+end_src

there are some real answers in there! So let's keep those for now.
*** what to do with people who did give consent but then didn't fill out anything else?
#+begin_src R :results none
  dat |>
    tidylog::filter(is.na(`Data Types`)) |>
    select(Consent:Q36_1_TEXT) |>
    as.data.frame() |>
    print()
#+end_src

that's 8 rows with only NA's, we filter them out

*** how many people did we reach and what status did they have?
#+begin_src R :results output graphics file :file imgs/contact_stacked.png :width 600 :height 250
  dat |>
    ggplot(aes(y = department, fill=Contact)) +
    geom_bar() +
    labs(x = NULL) +
    labs(title = str_wrap(Qs$question[Qs$column == "Contact"]))
#+end_src

#+RESULTS:
[[file:imgs/contact_stacked.png]]

** a single-select question
#+begin_src R :results output graphics file :file imgs/contact.png :width 600 :height 200
  dat |>
    ggplot(aes(y=Contact)) +
    geom_bar() +
    facet_grid(cols = vars(department))
#+end_src

#+RESULTS:
[[file:imgs/contact.png]]
** a multi-select question
*** prior to cleaning, figure out what to do
#+begin_src R :results output graphics file :file imgs/data_collection.png :width 600 :height 200
  dat |>
    # in this case one of the options has a comma, so we cannot split by , automatically :(
    mutate(`Data Collection` = str_replace(`Data Collection`,
                                           fixed("Measurements from a machine (e.g. camera, spectrometer, GPS/GNSS device, etc)"), "Measurements from a machine")) |>
    # this splits the multiple awnswers and puts them all in their own row, copying over the rest of the columns
    separate_rows(`Data Collection`, sep = ",") |>
    ggplot(aes(y = `Data Collection`)) +
    geom_bar() +
    labs(title = Qs$question[Qs$column == "Data Collection"], y = NULL) +
    facet_grid(cols = vars(department))
#+end_src

#+RESULTS:
[[file:imgs/data_collection.png]]
*** after cleaning
  #+begin_src R :results output graphics file :file imgs/Data Collection.png :width 600 :height 200
    dat |>
      separate_rows(`Data Types`, sep = ",") |>
      ggplot(aes(y=`Data Types`)) +
      geom_bar() +
      labs(title = Qs$question[Qs$column == "Data Types"], y = NULL) +
      facet_grid(cols = vars(department))
  #+end_src

  #+RESULTS:
  [[file:imgs/Data Collection.png]]

** a text question
*** with just a few distinct types of entries
#+begin_src R :results output graphics file :file imgs/Ethic Considerations.png :width 800 :height 600
  dat |>
    mutate(`Ethic Considerations` = ifelse(`Ethic Considerations` %in% c("N/A",
                                                                         "n.a.",
                                                                         "None",
                                                                         "none",
                                                                         "None.",
                                                                         "not relevant",
                                                                         "not applicable.",
                                                                         "Doesn't apply",
                                                                         "-",
                                                                         "Not applicable to my research",
                                                                         "N.A.",
                                                                         "N.a.",
                                                                         "N.a",
                                                                         "n/a"), "some form of 'Not applicable'", `Ethic Considerations`)) |>
    ggplot(aes(y=str_wrap(`Ethic Considerations`))) +
    ## geom_text_wordcloud()
    geom_bar() +
    labs(title = str_wrap(Qs$question[Qs$column == "Ethic Considerations"]), y = NULL) +
    facet_grid(cols = vars(department))
#+end_src

#+RESULTS:
[[file:imgs/Ethic Considerations.png]]
*** with some different options
#+begin_src R :results output graphics file :file imgs/Publication location_7_TEXT.png :width 600 :height 200
  dat |>
    ggplot(aes(label=str_wrap(`Publication location_7_TEXT`))) +
    geom_text_wordcloud() +
    ## geom_bar() +
    labs(title = str_wrap(Qs$question[Qs$column == "Publication location_7_TEXT"]), y = NULL) +
    facet_grid(cols = vars(department))
#+end_src

#+RESULTS:
[[file:imgs/Publication location_7_TEXT.png]]

*** with many different options
#+begin_src R :results output graphics file :file imgs/Neg Consequences.png :width 900 :height 700
  dat |>
    mutate(`Neg Consequences` = ifelse(`Neg Consequences` %in% c("N/A",
                                                                         "n.a.",
                                                                         "None",
                                                                         "none",
                                                                         "None.",
                                                                         "not relevant",
                                                                         "not applicable.",
                                                                         "Doesn't apply",
                                                                         "-",
                                                                         "--",
                                                                         "Not applicable to my research",
                                                                         "N.A.",
                                                                         "N.a.",
                                                                         "N.a",
                                                                         "n/a"), "some form of 'Not applicable'", `Neg Consequences`)) |>
    ggplot(aes(label=str_wrap(`Neg Consequences`))) +
    geom_text_wordcloud() +
    ## geom_bar() +
    labs(title = str_wrap(Qs$question[Qs$column == "Neg Consequences"]), y = NULL) +
    facet_grid(cols = vars(department))
#+end_src

#+RESULTS:
[[file:imgs/Neg Consequences.png]]

** come up with a recipe for single-select/multiselect/text questions
#+begin_src R
  make_plot <- function(typ, col) {
      if (typ == "single select") {
        pl <- dat |>
          ggplot(aes_string(y = glue::glue("`{col}`"))) +
          geom_bar() +
          labs(title = str_wrap(Qs$question[Qs$column == col]),
               subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                 str_wrap(Qs$clarification[Qs$column == col]),
                                 NULL),
               y = NULL) +
          facet_grid(cols = vars(department), scales = "free_x")
      } else if (typ == "multiple select") {
        pl <- dat |>
          separate_rows_(col, sep = ",") |>
          ggplot(aes_string(y = glue::glue("`{col}`"))) +
          geom_bar() +
          labs(title = str_wrap(Qs$question[Qs$column == col]),
               subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                 str_wrap(Qs$clarification[Qs$column == col]),
                                 NULL),
               y = NULL) +
          facet_grid(cols = vars(department), scales = "free_x")
      } else if (typ == "text entry") {
        # if there are few entries, just make a bar chart again
        ## if ((dat |> pull(col) |> unique() |> length()) < 10) {
        ##   pl <- dat |>
        ##     ggplot(aes_string(y = glue::glue("`{col}`"))) +
        ##     geom_bar() +
        ##     labs(title = str_wrap(Qs$question[Qs$column == col]),
        ##          subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
        ##                            str_wrap(Qs$clarification[Qs$column == col]),
        ##                            NULL),
        ##          y = NULL) +
        ##   facet_grid(cols = vars(department), scales = "free_x")
        ## } else {
          pl <- dat |>
            ggplot(aes_string(label = str_wrap(glue::glue("`{col}`"), width = 50))) +
            geom_text_wordcloud() +
            labs(title = str_wrap(Qs$question[Qs$column == col]),
                 subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                   str_wrap(Qs$clarification[Qs$column == col]),
                                   NULL),
                 y = NULL) +
          facet_grid(cols = vars(department), scales = "free_x")
      } else {
        warning(glue::glue("Incorrect typ: {typ} selected"))
      }
      pl
  }
#+end_src

#+RESULTS:

I also found [[https://semba-blog.netlify.app/11/05/2019/wordclouds-plotting-with-ggwordcloud-package-in-r/][this resource]] on making word clouds, but there were so few answers that this was not extra informative.

** test out the recipe on some examples
#+begin_src R
  # single select
  make_plot(Qs$type[[1]], Qs$column[[1]])

  # multiple select
  make_plot(Qs$type[[2]], Qs$column[[2]])
  make_plot(Qs$type[[9]], Qs$column[[9]])

  # other text options
  make_plot(Qs$type[[10]], Qs$column[[10]])
#+end_src

#+RESULTS:

** make the plot for each column
#+begin_src R :results none
  Qs <- Qs |>
    mutate(pl = map2(type, column, make_plot))
#+end_src

** save the plot for each column
#+begin_src R
  Qss <- Qs |> select(category, column, pl) |>
    mutate(rownum = row_number()) |>
    mutate(filename = paste0("imgs/", str_pad(rownum, side = "left", pad = "0", width = 3), "_", category, "_", column, ".png"))

  walk2(Qss$filename, Qss$pl, ~ ggsave(.x, plot = .y, width = 1920, height = 1080, units = "px", dpi = 200))
#+end_src

#+RESULTS:
: There were 50 or more warnings (use warnings() to see the first 50)

* now we need to decide which questions to dive deeper into
** backups
do the people who make manual backups and store stuff on their own pc also use different backup services? In that case it's not too bad.
#+begin_src R :results none
  dat |>
    distinct(`Data Storage`) |>
    print(n = Inf)
#+end_src

make a plot of the data storage location, but also indicate which other answers people have indicated so that we can see which ones are potentially problematic:
#+begin_src R
  dat |>
    ## tidylog::filter(str_detect(`Data Storage`, "My computer")) |>
    separate_rows(`Data Storage`, sep = ",") |>
    group_by(ResponseId) |>
    mutate(n_answer = n()) |>
    ggplot(aes(y=`Data Storage`)) +
    geom_bar(alpha = .3) +
    stat_count(aes(group = ResponseId, colour = as.integer(n_answer)), geom = "line") +
    stat_count(aes(group = ResponseId, colour = as.integer(n_answer)), size = 3, geom = "point") +
    labs(title = Qs$question[Qs$column == "Data Storage"], y = NULL)
#+end_src

We can filter by people who have their current projects only stored locally, not even on a USB-key

We also want to know if they filled out contact info so we can reach out to them if possible
#+begin_src R :results none
  dat |>
    ## tidylog::filter(str_detect(`Data Storage`, "My computer")) |>
    separate_rows(`Data Storage`, sep = ",") |>
    group_by(ResponseId) |>
    mutate(n_answer = n()) |>
    # how many use only their own computer?
    tidylog::filter(n_answer == 1 && str_detect(`Data Storage`, "My computer")) |>
    distinct(`Data Storage`, `Data Backup`, `Data Backup_3_TEXT`, ResponseId, Contact, Q36_1_TEXT) |> print(n = Inf)
#+end_src

Or people who do use local storage and do not backup automatically
#+begin_src R :results none
  dat |>
    ## tidylog::filter(str_detect(`Data Storage`, "My computer")) |>
    separate_rows(`Data Storage`, sep = ",") |>
    group_by(ResponseId) |>
    mutate(n_answer = n()) |>
    # or their own computer + something else?
    tidylog::filter(n_answer > 1) |>
    # is it NOT backed up automatically?
    tidylog::filter(`Data Backup` |> str_detect("automatically", negate = TRUE)) |>
    distinct(`Data Storage`, `Data Backup`, `Data Backup_3_TEXT`, .keep_all = TRUE) |>
    select(`Data Storage`, `Data Backup`, `Data Backup_3_TEXT`, ResponseId, Contact, Q36_1_TEXT) |>
    print(n = Inf)
#+end_src

** versioning and publishing of code
who isn't versioning their code?
#+begin_src R
  dat |>
    tidylog::filter(Versioning |> str_detect("No:")) |>
    count(Versioning, `Publication location`)
#+end_src

** license
there are many people who do not assign a license to their code
#+begin_src R
  dat |>
    tidylog::filter(`Code License` |> str_detect("No")) |>
    count(`Code License`, `Publication location`)
#+end_src

if you don't publish your code, assigning a license isn't such a big deal. If you do, it would be better!

** doi
a lot of code does not have a doi associated with it
#+begin_src R
  dat |>
    separate_rows(`Publication location`, sep = ",") |>
    tidylog::filter(`Publication location` |> str_detect("not publish", negate = TRUE)) |>
    ## tidylog::filter(`Code DOI` |> str_detect("Not?")) |>
    count(`Publication location`, `Code DOI`)
#+end_src


** look at guidelines
#+begin_src R
  dat |>
   distinct(`Research Guidelines_1_TEXT`) |> pull(`Research Guidelines_1_TEXT`)
#+end_src

#+begin_src R
  dat |>
   distinct(`Research Guidelines_2_TEXT`) |> pull(`Research Guidelines_2_TEXT`)
#+end_src

#+begin_src R
  dat |>
   distinct(`Research Guidelines_3_TEXT`) |> pull(`Research Guidelines_3_TEXT`)
#+end_src
** useful
#+begin_src R
  dat |>
    distinct(`Resources for RDM_7_TEXT`) |> pull(`Resources for RDM_7_TEXT`)
#+end_src
** q's
#+begin_src R
  dat |>
    distinct(`Any Questions`) |> pull(`Any Questions`)
#+end_src

* try out sankey diagrams for relations between questions
** data types and collection
#+begin_src R :results output graphics file :file imgs/sankey_data.png :width 700
  dat |>
    separate_rows(`Data Collection`, sep = ",") |>
    separate_rows(`Data Types`, sep = ",") |>
    make_long(`Data Types`, `Data Collection`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = .6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = Qs$question[Qs$column %in% c("Data Types", "Data Collection")]) +
    ## labs(title = str_wrap(Qs$question[Qs$column == "Data Types"]), y = NULL)
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_data.png]]

** open data
#+begin_src R :results output graphics file :file imgs/sankey_open_data.png :width 800
  dat |>
    separate_rows(`Open Data Formats`, sep = ",") |>
    separate_rows(`Conversion`, sep = ",") |>
    make_long(`Open Data Formats`, `Conversion`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = Qs$question[Qs$column %in% c("Open Data Formats", "Conversion")]) +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_open_data.png]]

** code and versioning
#+begin_src R :results output graphics file :file imgs/sankey_open_code.png :width 800
  dat |>
    separate_rows(`Skip Code`, sep = ",") |>
    separate_rows(`Versioning`, sep = ",") |>
    make_long(`Skip Code`, `Versioning`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = Qs$question[Qs$column %in% c("Skip Code", "Versioning")]) +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_open_code.png]]

** FAIR and storage, grouped by level
#+begin_src R :results output graphics file :file imgs/sankey_FAIR_data.png :width 800
  dat |>
    ## separate_rows(`Code License`, sep = ",") |>
    separate_rows(`Storage`, sep = ",") |>
    make_long(`FAIR Application`, `Storage`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = str_wrap(Qs$question[Qs$column %in% c("FAIR Application", "Storage")])) +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_FAIR_data.png]]

** FAIR and code + share location + code license + DOI by level
#+begin_src R :results output graphics file :file imgs/sankey_FAIR_code.png :width 800
  dat |>
    separate_rows(`Code License`, sep = ",") |>
    separate_rows(`Versioning`, sep = ",") |>
    separate_rows(`Publication location`, sep = ",") |>
    make_long(`FAIR Application`, `Skip Code`, `Publication location`, `Code License`, `Code DOI`, Contact) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), size = 3.5, hjust = 0) +
    theme_sankey() +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_FAIR_code.png]]

* try out alluvial                             :noexport:
alluvial needs frequencies or numbers in the data

this currently does not work.
#+begin_src R
  library(ggalluvial)
  dat |>
    ggplot(aes(axis1 = `Open Data Formats`, axis2 = `Conversion`, y = stat(count))) +
    geom_alluvial() +
    geom_stratum() +
    geom_text(stat = "stratum",
              aes(label = after_stat(stratum))) +
    scale_x_discrete(limits = c("Survey", "Response"),
                     expand = c(0.15, 0.05)) +
    theme_void()
#+end_src
