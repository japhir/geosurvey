#+title: data steward survey 2021 --- processing & scratchpad
# this sets the properties for all R source code blocks, so they are all related to the session
#+property: header-args:R  :session *R:survey* :exports results :results output :eval no-export

* libraries
#+begin_src R :results none
  # install.packages("tidyverse")
  library(tidyverse)

  #remotes::install_github("davidsjoberg/ggsankey")
  library(ggsankey)
  # install.packages("ggalluvial")
  ## library(ggalluvial)
  # install.packages("tidylog")

  # install.packages("ggwordcloud")
  library(ggwordcloud)
#+end_src

* read in the data                                     :noexport:
#+begin_src R :results none
  raw <- read_csv(
    ## "dat/2021 Earth Sciences Data Steward Survey_November 29, 2021_03.23.csv",
    "dat/2021 Earth Sciences Data Steward Survey_December 6, 2021_02.20.csv",
    trim_ws = TRUE, col_names = TRUE)

  dat <- raw |>
    tidylog::filter(StartDate != "Start Date") |>
    tidylog::filter(!stringr::str_detect(StartDate, "[{]")) |>
    type_convert(col_types = "TTccidcT?????????????????????????????????????????????????????????????") |>
    tidylog::mutate(Finished = ifelse(Finished == "True", TRUE, FALSE),
                    Consent = ifelse(Consent == "Yes", TRUE, FALSE))

  glimpse(dat)
#+end_src

* read in the questions/types
Unfortunately, I had to make this manually. It's necessary for the plot titles and such.
#+begin_src R :results none
  Qs <- read_csv("dat/survey_questions.csv") |>
     mutate(clarification = ifelse(is.na(clarification), "", clarification))
#+end_src

** did we put all the necessary columns in the file?
#+begin_src R :results value
  colnames(dat)[!colnames(dat) %in% Qs$column]
#+end_src

#+RESULTS:
| StartDate             |
| EndDate               |
| Status                |
| IPAddress             |
| Progress              |
| Duration (in seconds) |
| Finished              |
| RecordedDate          |
| ResponseId            |
| RecipientLastName     |
| RecipientFirstName    |
| RecipientEmail        |
| ExternalReference     |
| LocationLatitude      |
| LocationLongitude     |
| DistributionChannel   |
| UserLanguage          |

looks like I did, these are only tracking metadata which are mostly empty because we used anonymous urls to get the survey responses.
* tidy the data                                        :noexport:
** tidy up all multiselect answers so they can be split up if desired
inspect all unique values in a variable
#+begin_src R :results none
  dat |> distinct(`Data Types`)
#+end_src

Tidy up the multiselect answers (remove parentheses and commas)
#+begin_src R :results none
  dat <-
    dat |>
    # get rid of examples
    tidylog::mutate(`Data Types` = str_replace_all(`Data Types`, " \\([0-9A-Za-z, ]+\\)", "")) |>
    tidylog::mutate(`Data Collection` = str_replace_all(`Data Collection`, "machine ,", "machine,")) |>
    tidylog::mutate(`Data Collection` = str_replace_all(`Data Collection`, " \\(.*\\)", "")) |>
    # this has Yes, answers everywhere, just replace the , with a :
    tidylog::mutate(`Data Re-use` = str_replace_all(`Data Re-use`, "Yes,", "Yes:")) |>
    # Data Storage is fine!
    tidylog::mutate(`Data Backup` = str_replace_all(`Data Backup`, " \\(.*\\)", "")) |>
    # File Structure = fine
    # FAIR Application is single-select
    tidylog::mutate(`Storage` = str_replace_all(`Storage`, ", namely", "; namely")) |>
    tidylog::mutate(`Open Data Formats` = str_replace_all(`Open Data Formats`, " \\(.*\\)", "")) |>
    tidylog::mutate(`Open Data Formats` = str_replace_all(`Open Data Formats`, ", I use", "; I use")) |>
    # Conversion is good
    # Project Replication is fine
    tidylog::mutate(`Metadata Provided` = str_replace_all(`Metadata Provided`, " \\(.*\\)", "")) |>
    tidylog::mutate(`Skip Code` = str_replace_all(`Skip Code`, " \\([0-9A-Za-z, +]+\\)", "")) |>
    tidylog::mutate(`Skip Code` = str_replace_all(`Skip Code`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Skip Code` = str_replace_all(`Skip Code`, "No,", "No:")) |>
    tidylog::mutate(`Versioning` = str_replace_all(`Versioning`, "\\([0-9A-Za-z, +]+\\)", "")) |>
    tidylog::mutate(`Versioning` = str_replace_all(`Versioning`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Versioning` = str_replace_all(`Versioning`, "No,", "No:")) |>
    # Publication location is good
    tidylog::mutate(`Code License` = str_replace_all(`Code License`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Code License` = str_replace_all(`Code License`, "No,", "No:")) |>
    tidylog::mutate(`Code License` = str_replace_all(`Code License`, " \\(.*\\)", "")) |>
    # Code DOI is good
    # Personal Data Bool is fine
    tidylog::mutate(`Personal Data Bool` = str_replace_all(`Personal Data Bool`, " \\(.*\\)", "")) |>
    # GDPR Work
    # Privacy Review DPIA
    # Sharing Private Data
    # Personal Training
    # Finding Privacy
    # Neg Consequences
    # Ethic Considerations
    tidylog::mutate(`Research Guidelines` = str_replace_all(`Research Guidelines`, " \\(.*\\)", "")) |>
    tidylog::mutate(`Research Guidelines` = str_replace_all(`Research Guidelines`, "Yes,", "Yes:")) |>
    tidylog::mutate(`Research Guidelines` = str_replace_all(`Research Guidelines`, "No,", "No: ")) |>
    tidylog::mutate(`Q36` = str_replace_all(`Q36`, " \\(.*\\)", ""))
#+end_src

Doing the actual split results in way too many rows, messing up the counts.
Thus it needs to be done separately for each plot?

** COMMENT replace NA with hard coded "N/A" for nicer sankey diagrams
I don't like this too much, only do it for the sankey diagrams
#+begin_src R :results none
   dat <- dat |>
    tidylog::mutate(across(.cols = where(~ is.character(.x)), .fns = ~ replace(.x, is.na(.x), "N/A")))
#+end_src

** clean up research guidelines
Turns out we messed this question up a bit
#+begin_src R :results none
  distinct(dat, `Research Guidelines`)
#+end_src

#+begin_src R :results none
  dat <- dat |>
    mutate(`Research Guidelines` = `Research Guidelines` |>
             str_replace_all("^No$", "No: I don't know any guidelines") |>
             str_replace_all("^I don't know any guidelines", "No: I don't know any guidelines") |>
             str_replace_all(",I don't know any guidelines", ",No: I don't know any guidelines"))
  dat |>
    distinct(`Research Guidelines`)
#+end_src

** NEXT tidy up open text entries for summaries
I've marked all columns that could do with some cleaning up in yellow in the [[file:dat/survey_questions.ods]] file

** filter out people who did not give consent
#+begin_src R
  dat <- dat |>
     tidylog::filter(!Consent | !is.na(Consent)) # no consent or not filled out
#+end_src

** filter out people who did not fill out any of the questions
#+begin_src R
  empty <- dat |>
    mutate(across(.cols = `Data Types`:Q36_1_TEXT, .fns = is.na)) %>%
    mutate(allcols = rowSums(select(., `Data Types`:Q36_1_TEXT)) ==
             colnames(dat |> select(`Data Types`:Q36_1_TEXT)) |> length())

  dat <- dat |>
    tidylog::filter(!ResponseId %in% empty$ResponseId[empty$allcols])
#+end_src

** export cleaned up data
#+begin_src R :results none
  dat |>
    write_rds("out/tidy_survey.rds")
#+end_src

** read in cleaned up data
#+begin_src R :results none
  dat <- read_rds("out/tidy_survey.rds")
#+end_src

* design an approach
** get an overview of survey respondents
Some of these will be used to filter out non-real participants from the survey results.
*** did people complete the survey?
#+begin_src R :results output graphics file :file imgs/responses.png :width 800
  dat |>
    arrange(RecordedDate) |>
    ## tidylog::filter(!is.na(Consent)) |> # 9 people didn't give consent and then didn't fill anything out
    ## tidylog::filter(`Duration (in seconds)` < 60 * 60) |> # 6 more took longer than an hour
    ## tidylog::filter(Progress > 50) |>  # 9 remaining people were less than 50% complete
    ggplot(aes(x = StartDate, xend = EndDate, y = `Duration (in seconds)` / 60, colour = Progress)) +
    geom_segment(aes(yend = `Duration (in seconds)` / 60, group = ResponseId), size = 1.5) +
    geom_point(aes(x = RecordedDate)) +
    scale_colour_viridis_c(direction = -1) +
    labs(y = "Duration (in minutes)")
#+end_src

#+RESULTS:
[[file:imgs/responses.png]]
*** how long did people actually take to fill out the survey?
#+begin_src R :results output graphics file :file imgs/duration.png :width 800
  dat |>
    ggplot(aes(x = `Duration (in seconds)`/60)) +
    geom_histogram() +
    geom_vline(xintercept = median(dat$`Duration (in seconds)`) / 60) +
    labs(x = "Duration (in minutes)")
#+end_src

#+RESULTS:
[[file:imgs/duration.png]]

The people who finished filling out the survey took about 10.28 minutes!

#+begin_src R :results none
  median(dat$`Duration (in seconds)`) / 60
#+end_src

#+begin_src R :results none
  getmode <- function(v) {
     uniqv <- unique(v)
     uniqv[which.max(tabulate(match(v, uniqv)))]
  }

  getmode(dat$`Duration (in seconds)`) / 60
#+end_src

with a mode of about 6 minutes.

*** did the partially complete cases give useful input?
#+begin_src R :results none
  dat |>
    tidylog::filter(!Finished) |>
    select(Consent:Q36_1_TEXT) |>
    as.data.frame() |>
    print()
#+end_src

there are some real answers in there! So let's keep those for now.
*** what to do with people who did give consent but then didn't fill out anything else?
#+begin_src R :results none
  dat |>
    tidylog::filter(is.na(`Data Types`)) |>
    select(Consent:Q36_1_TEXT) |>
    as.data.frame() |>
    print()
#+end_src

that's 8 rows with only NA's, we filter them out

*** how many people did we reach and what status did they have?
#+begin_src R :results output graphics file :file imgs/contact_stacked.png :width 600 :height 150
  dat |>
    ggplot(aes(x = "Contact", fill=Contact)) +
    geom_bar() +
    coord_flip() +
    labs(x = NULL) +
    labs(title = str_wrap(Qs$question[Qs$column == "Contact"]))
#+end_src

#+RESULTS:
[[file:imgs/contact_stacked.png]]
** a single-select question
#+begin_src R :results output graphics file :file imgs/contact.png :width 600 :height 200
  dat |>
    ggplot(aes(y=Contact)) +
    geom_bar()
#+end_src

#+RESULTS:
[[file:imgs/contact.png]]
** a multi-select question
*** prior to cleaning, figure out what to do
#+begin_src R :results output graphics file :file imgs/data_collection.png :width 600 :height 200
  dat |>
    # in this case one of the options has a comma, so we cannot split by , automatically :(
    mutate(`Data Collection` = str_replace(`Data Collection`,
                                           fixed("Measurements from a machine (e.g. camera, spectrometer, GPS/GNSS device, etc)"), "Measurements from a machine")) |>
    # this splits the multiple awnswers and puts them all in their own row, copying over the rest of the columns
    separate_rows(`Data Collection`, sep = ",") |>
    ggplot(aes(y = `Data Collection`)) +
    geom_bar() +
    labs(title = Qs$question[Qs$column == "Data Collection"], y = NULL)
#+end_src

#+RESULTS:
[[file:imgs/data_collection.png]]
*** after cleaning
  #+begin_src R :results output graphics file :file imgs/Data Collection.png :width 600 :height 200
    dat |>
      separate_rows(`Data Types`, sep = ",") |>
      ggplot(aes(y=`Data Types`)) +
      geom_bar() +
      labs(title = Qs$question[Qs$column == "Data Types"], y = NULL)
  #+end_src

  #+RESULTS:
  [[file:imgs/Data Collection.png]]

** a text question
*** with just a few distinct types of entries
#+begin_src R :results output graphics file :file imgs/Ethic Considerations.png :width 800 :height 600
  dat |>
    mutate(`Ethic Considerations` = ifelse(`Ethic Considerations` %in% c("N/A",
                                                                         "n.a.",
                                                                         "None",
                                                                         "none",
                                                                         "None.",
                                                                         "not relevant",
                                                                         "not applicable.",
                                                                         "Doesn't apply",
                                                                         "-",
                                                                         "Not applicable to my research",
                                                                         "N.A.",
                                                                         "N.a.",
                                                                         "N.a",
                                                                         "n/a"), "some form of 'Not applicable'", `Ethic Considerations`)) |>
    ggplot(aes(y=str_wrap(`Ethic Considerations`))) +
    ## geom_text_wordcloud()
    geom_bar() +
    labs(title = str_wrap(Qs$question[Qs$column == "Ethic Considerations"]), y = NULL)
    ## distinct(`Ethic Considerations`)
#+end_src

#+RESULTS:
[[file:imgs/Ethic Considerations.png]]
*** with some different options
#+begin_src R :results output graphics file :file imgs/Publication location_7_TEXT.png :width 600 :height 200
  dat |>
    ggplot(aes(label=str_wrap(`Publication location_7_TEXT`))) +
    geom_text_wordcloud() +
    ## geom_bar() +
    labs(title = str_wrap(Qs$question[Qs$column == "Publication location_7_TEXT"]), y = NULL)
    ## distinct(`Publication location_7_TEXT`)
#+end_src

#+RESULTS:
[[file:imgs/Publication location_7_TEXT.png]]

*** with many different options
#+begin_src R :results output graphics file :file imgs/Neg Consequences.png :width 900 :height 700
  dat |>
    mutate(`Neg Consequences` = ifelse(`Neg Consequences` %in% c("N/A",
                                                                         "n.a.",
                                                                         "None",
                                                                         "none",
                                                                         "None.",
                                                                         "not relevant",
                                                                         "not applicable.",
                                                                         "Doesn't apply",
                                                                         "-",
                                                                         "--",
                                                                         "Not applicable to my research",
                                                                         "N.A.",
                                                                         "N.a.",
                                                                         "N.a",
                                                                         "n/a"), "some form of 'Not applicable'", `Neg Consequences`)) |>
    ggplot(aes(label=str_wrap(`Neg Consequences`))) +
    geom_text_wordcloud() +
    ## geom_bar() +
    labs(title = str_wrap(Qs$question[Qs$column == "Neg Consequences"]), y = NULL)
    ## distinct(`Neg Consequences`)
#+end_src

#+RESULTS:
[[file:imgs/Neg Consequences.png]]

** come up with a recipe for single-select/multiselect/text questions
#+begin_src R
  make_plot <- function(typ, col) {
      if (typ == "single select") {
        pl <- dat |>
          ggplot(aes_string(y = glue::glue("`{col}`"))) +
          geom_bar() +
          labs(title = str_wrap(Qs$question[Qs$column == col]),
               subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                 str_wrap(Qs$clarification[Qs$column == col]),
                                 NULL),
               y = NULL)
      } else if (typ == "multiple select") {
        pl <- dat |>
          separate_rows_(col, sep = ",") |>
          ggplot(aes_string(y = glue::glue("`{col}`"))) +
          geom_bar() +
          labs(title = str_wrap(Qs$question[Qs$column == col]),
               subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                 str_wrap(Qs$clarification[Qs$column == col]),
                                 NULL),
               y = NULL)
      } else if (typ == "text entry") {
        # if there are few entries, just make a bar chart again
        if ((dat |> pull(col) |> unique() |> length()) < 10) {
          pl <- dat |>
            ggplot(aes_string(y = glue::glue("`{col}`"))) +
            geom_bar() +
            labs(title = str_wrap(Qs$question[Qs$column == col]),
                 subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                   str_wrap(Qs$clarification[Qs$column == col]),
                                   NULL),
                 y = NULL)
        } else {
          pl <- dat |>
            ggplot(aes_string(label = str_wrap(glue::glue("`{col}`"), width = 50))) +
            geom_text_wordcloud() +
            labs(title = str_wrap(Qs$question[Qs$column == col]),
                 subtitle = ifelse(!is.na(Qs$clarification[Qs$column == col]),
                                   str_wrap(Qs$clarification[Qs$column == col]),
                                   NULL),
                 y = NULL)
        }
      }
      pl
  }
#+end_src

#+RESULTS:

I also found [[https://semba-blog.netlify.app/11/05/2019/wordclouds-plotting-with-ggwordcloud-package-in-r/][this resource]] on making word clouds, but there were so few answers that this was not extra informative.

** test out the recipe on some examples
#+begin_src R
  make_plot(Qs$type[[2]], Qs$column[[2]])

  make_plot(Qs$type[[1]], Qs$column[[1]])

  make_plot(Qs$type[[9]], Qs$column[[9]])
  make_plot(Qs$type[[10]], Qs$column[[10]])
#+end_src

#+RESULTS:

** make the plot for each column
#+begin_src R :results none
  Qs <- Qs |>
    mutate(pl = map2(type, column, make_plot))
#+end_src

** save the plot for each column
#+begin_src R
  Qss <- Qs |> select(category, column, pl) |>
    mutate(rownum = row_number()) |>
    mutate(filename = paste0("imgs/", str_pad(rownum, side = "left", pad = "0", width = 3), "_", category, "_", column, ".png"))

  walk2(Qss$filename, Qss$pl, ~ ggsave(.x, plot = .y, width = 1920, height = 1080, units = "px", dpi = 200))
#+end_src

#+RESULTS:
: There were 13 warnings (use warnings() to see them)

* try out sankey diagrams for relations between questions
** data types and collection
#+begin_src R :results output graphics file :file imgs/sankey_data.png :width 700
  dat |>
    separate_rows(`Data Collection`, sep = ",") |>
    separate_rows(`Data Types`, sep = ",") |>
    make_long(`Data Types`, `Data Collection`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = .6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = Qs$question[Qs$column %in% c("Data Types", "Data Collection")]) +
    ## labs(title = str_wrap(Qs$question[Qs$column == "Data Types"]), y = NULL)
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_data.png]]

** open data
#+begin_src R :results output graphics file :file imgs/sankey_open_data.png :width 800
  dat |>
    separate_rows(`Open Data Formats`, sep = ",") |>
    separate_rows(`Conversion`, sep = ",") |>
    make_long(`Open Data Formats`, `Conversion`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = Qs$question[Qs$column %in% c("Open Data Formats", "Conversion")]) +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_open_data.png]]

** code and versioning
#+begin_src R :results output graphics file :file imgs/sankey_open_code.png :width 800
  dat |>
    separate_rows(`Skip Code`, sep = ",") |>
    separate_rows(`Versioning`, sep = ",") |>
    make_long(`Skip Code`, `Versioning`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = Qs$question[Qs$column %in% c("Skip Code", "Versioning")]) +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_open_code.png]]

** FAIR and storage, grouped by level
#+begin_src R :results output graphics file :file imgs/sankey_FAIR_data.png :width 800
  dat |>
    ## separate_rows(`Code License`, sep = ",") |>
    separate_rows(`Storage`, sep = ",") |>
    make_long(`FAIR Application`, `Storage`) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), hjust = 0) +
    theme_sankey() +
    scale_x_discrete(labels = str_wrap(Qs$question[Qs$column %in% c("FAIR Application", "Storage")])) +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_FAIR_data.png]]

** FAIR and code + share location + code license + DOI by level
#+begin_src R :results output graphics file :file imgs/sankey_FAIR_code.png :width 800
  dat |>
    separate_rows(`Code License`, sep = ",") |>
    separate_rows(`Versioning`, sep = ",") |>
    separate_rows(`Publication location`, sep = ",") |>
    make_long(`FAIR Application`, `Skip Code`, `Publication location`, `Code License`, `Code DOI`, Contact) |>
    ggplot(aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node))) +
    geom_sankey(flow.alpha = 0.6) +
    geom_sankey_text(aes(label = node), size = 3.5, hjust = 0) +
    theme_sankey() +
    theme(legend.pos = "none", axis.title.x = element_blank())
#+end_src

#+RESULTS:
[[file:imgs/sankey_FAIR_code.png]]

* try out alluvial                             :noexport:
alluvial needs frequencies or numbers in the data

this currently does not work.
#+begin_src R
  library(ggalluvial)
  dat |>
    ggplot(aes(axis1 = `Open Data Formats`, axis2 = `Conversion`, y = stat(count))) +
    geom_alluvial() +
    geom_stratum() +
    geom_text(stat = "stratum",
              aes(label = after_stat(stratum))) +
    scale_x_discrete(limits = c("Survey", "Response"),
                     expand = c(0.15, 0.05)) +
    theme_void()
#+end_src
